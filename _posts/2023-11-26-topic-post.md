---
title: "Snake AI!"
date: 2023-11-26
categories:
  - blog
tags:
  - Coding
  - AI
---

Hello again! In this post, I am going to reflect on one of my assignments that I have for my AI Theory course.

This is a pretty big project that I have going on: basically, I'm being told to select a videogame and use the AI methods and practices we learned in class to develop a working AI that plays the game. I decided to pick the Snake Game- a simple game where your goal is to traverse the board and eat fruit to grow in size. The game gets progressively harder as you grow longer, since colliding with any part of your snake body or the boundaries of the board results in a game over. To win, you must fill up the entire board with snake body segments. 

This is my general approach that I am taking towards developing this AI: I want to make my AI win as often as possible, while also completing the game as quick as possible. You see, what's interesting about the game of snake is that there actually exists a strategy where you're guaranteed to win the game, and that is by following a Hamiltonian Cycle. A Hamiltonian Cycle is a fancy mathematical term pertaining to pathfinding in a 2d space, but put simply, all you're really doing is following a path in which you visit every square on the board once, and then repeat this path until you eventually win. The problem with this solution is that, quite frankly, it is boring. 

So for the snake AI I'm creating, my plan is to dynamically select between three pathfinding strategies based on the state of the board. Currently, my AI has access to the following information: a list of tuples representing each of its body segments (ordered so that the head is the first element and the tail is the last element), the fruit position, the board dimensions, and the facing direction (represented as ‘UP’ ‘DOWN’ ‘LEFT’ and ‘RIGHT’). 

The first path finding strategy I’ve come up with is to perform DFS (depth-first search) on only the rectangular area formed by the head of the snake and the fruit position. DFS is a type of pathfinding algorithm that explores nodes of a tree-graph on a "depth-first" priority; put simply, DFS is the most optimal algorithm to use in this particular search area. The idea behind this strategy is finding the absolute shortest route to the fruit based on the Manhattan Distance between the head and the fruit. Conveniently, such paths always lie within that rectangular area I described, as long as 1) the snake moves closer to the fruit each move, and 2) there is no obstacle impeding the snake’s movement. This means the DFS tree only needs a branching factor of 2, since for any given game state, there are, at most, 2 directions the snake can move in order to shorten the Manhattan Distance to the fruit. In other words, not only is DFS most efficient in this scenario; it's also heavily optimized. I’ve also added two “heuristics” to help DFS decide between the two choices of direction it has: 1) if one move would result in the snake’s head being adjacent to a greater number of body segments than the other move, it should choose the move with more adjacencies; 2) if both moves would place the snake adjacent to an equal number of body segments, then DFS should prioritize moving in the same direction as the previous move (so for example, if it moved ‘UP’ on the previous move and is choosing between ‘UP’ and ‘RIGHT’ on the next move, it should choose ‘UP’ to align with the previous move).

The second path finding strategy utilizes A* to find the optimal path when DFS is unable to find a path. A* is known in the computer science world as one of the most efficient pathfinding algorithm in almost all situations. I’m still optimizing this algorithm, but essentially what I think I want to do is apply a penalty cost for all squares that DFS searched in order to deter A* from pathfinding in those squares, since there is a lower chance for the optimal path to utilize these squares. The other heuristics for A* would be 1) distance to the fruit, 2) adjacency to body segments, and 3) move results in a game over. I can optimize the algorithm by preventing A* from searching the square immediately behind the head, since the game doesn’t allow for 180 degree turns. This gives the tree a branching factor of 3.

The third strategy is something I’m still trying to figure out. I know I want the AI to play as safe as possible when this strategy is selected, but that raises the question of what game state the AI would need to be in for it to decide that safety is the number one priority. The idea I'm currently investigating involves storing the highest and lowest row and column on the board in which there exists a snake body segment. So for example, if the snake is on a 15x17 board, and the list of snake positions is [(7, 3), (7, 4), (7, 5), (7, 6)], the highest row would be 7, the lowest row would be 7, the highest column would be 6, and the lowest column would be 3. If you connect these points in a rectangular fashion, you can guarantee that every body segment of the snake must be contained within this rectangular area. Using Python's zip() function, I'm able to get these four points in O(n) time, but I think I can actually do it in O(1) time for subsequent moves as long as I store these points and compare them to the new positions of the head/tail (these are the only body segments which have the potential to change the highest/lowest row/col). My idea in knowing the highest/lowest row/column is to try and determine whether certain areas of the board are inaccessible. So if the lowest row is 0 and highest is 14 (there are 15 rows in a 15x17 board), then we know for a fact that there is some area of the board which is inaccessible. To illustrate this, say the snake occupies positions (0, 3) through (14, 3), the head is at (14, 4), and the tail is at (0, 4): in such a situation, columns 0-2 would be completely inaccessible until either the lowest row increases by 1, or the highest row decreases by 1. Now, this is a neat property, but I don't think this alone would be enough to determine all inaccessible areas on the board. Additionally, the AI needs to be able to use information about inaccessible areas in a meaningful way, and currently the only way I can think of to utilize this involves determining *when* an inaccessible area will become accessible again. Though, I haven't thought far ahead enough to determine how expensive this sort of operation may be. 

That is essentially what I've been doing the majority of this semeseter in that class. It's been extremely challenging, but I've honestly had tons of fun brainstorming these ideas and coming up with ways to improve my AI.